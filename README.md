# Global Sensitivity Analysis of an ODE Model for sRNA-RNA interaction

This repository contains R scripts to perform a Global Sensitivity Analysis (GSA) using Sobol' methods on an Ordinary Differential Equation (ODE) model for sRNA-RNA interaction, as described in the paper "Harnessing small RNAs as synthetic post-transcriptional regulators in prokaryotes" (DOI). The analysis aims to identify which model parameters most significantly influence a defined output metric, considering both individual (first-order) and total-order effects (including interactions).

## Methodology Overview

The GSA process involves the following key steps, implemented in the scripts:

1.  **Model Definition**: An ODE model describing the system dynamics is defined.
2.  **Output Metric**: A specific output metric is calculated from the steady-state or time-course simulation of the ODE model. In this example, it's "Protein Regulation Strength," calculated as the log2 fold change of protein concentration under a specific condition versus a baseline condition.
3.  **Parameter Definition**: Model parameters for GSA are identified, along with their uncertainty ranges and sampling distributions (uniform or log-uniform).
4.  **Sobol' Sampling**: Sobol's quasi-random sampling method is used to generate parameter sets from the defined ranges and distributions. This method is efficient for exploring the parameter space and calculating sensitivity indices. The `sensitivity::sobolSalt` function is used.
5.  **Model Execution**: The ODE model is run for each parameter set generated by the Sobol' sequence. This step is parallelized here.
6.  **Sensitivity Indices Calculation**: First-order (S1) and total-order (ST) Sobol' sensitivity indices are calculated.
    * S1: Measures the contribution of a single parameter's variance to the output variance (main effect).
    * ST: Measures the total contribution of a parameter, including its main effect and all interactions with other parameters.
7.  **Result Visualization & Storage**: Sobol indices are plotted, and the GSA design matrix along with model outputs are saved for further post-processing (like the interaction and ratio analyses we discussed previously).

## How to Run

1.  **Prerequisites**:
    * R installed.
    * Required R packages installed: `deSolve`, `sensitivity`, `dplyr`, `parallel`, `ggplot2`, `tidyr`. You can install them using:
        ```R
        install.packages(c("deSolve", "sensitivity", "dplyr", "parallel", "ggplot2", "tidyr"))
        ```
2.  **Clone the Repository** (if applicable).
3.  **Open `run_gsa_analysis.R`** in RStudio or your preferred R environment.
4.  **Adjust Parameters**:
    * Modify `baseline_params` in `run_gsa_analysis.R` if needed.
    * Update `gsa_parameters` in `run_gsa_analysis.R` to define the parameters you want to vary, their min/max ranges, and their sampling distributions (`uniform` or `loguniform`).
    * Adjust `n_base_samples` for the Sobol' sequence. Higher values give more robust indices but take longer to compute.
5.  **Run the Script**: Execute `run_gsa_analysis.R`.

The script will perform the GSA and save the Sobol' indices plot and an `.RData` file containing the Sobol' design object and the GSA results (including unscaled parameters and corresponding outputs) into the `results/` directory.

## Further Analysis

The output `gsa_results_with_inputs_df` (saved in the `.RData` file) from this GSA can be used as input for more detailed post-processing, such as:
* Scatter plots of individual parameters vs. the output.
* Fitting linear models to explore main effects.
* Investigating pairwise interactions (product terms).
* Testing specific non-linear relationships (e.g., ratios).
* Generating conditional effect plots.

## Code Overview

### `run_gsa_analysis.R`
* Loads required packages and sources helper functions.
* Defines global constants and baseline parameters.
* Sets up GSA parameters (ranges, distributions).
* Calls functions from `src/gsa_sobol_functions.R` to perform Sobol sampling and run simulations in parallel.
* Processes and plots Sobol' indices.
* Unscales parameter samples and saves the combined input-output dataframe.

### `src/model_and_metric_functions.R`
* `model_func_gsa`: The ODE function compatible with `deSolve::ode`.
* `calculate_protein_regulation_strength`: Calculates the output metric from ODE simulation results.

### `src/gsa_sobol_functions.R`
* `single_gsa_run`: A wrapper function to run a single ODE simulation with a given parameter set (unscaling parameters based on their distribution) and calculate the output metric. This is designed for use with `parApply`.
* (Potentially other helper functions for GSA setup or post-processing if you expand).

---
---

**1. `src/model_and_metric_functions.R`:**
   This file will contain your core model and how you calculate your output.

   ```R
   # src/model_and_metric_functions.R

   # --- Global Constants (relevant to model/metric calculation) ---
   F_KON_CONVERSION <- 6.022e23 * 1e-15 # for conversion from M to molecule based k_on with the assumed voume of an E. coli cell 1e-15 L
   PSEUDO_COUNT <- 1e-9
   TIME_FOR_STEADY_STATE <- 50000 # Or pass as argument if it varies

   # --- ODE Model Function ---
   model_func_gsa <- function(time, state, parameters) {
     with(as.list(c(state, parameters)), {
       dm <- k_elon * m_pre - beta_m * m - k_on * m * s + k_off * ms
       dms <- k_on * m * s + k_elon * m_pre_s - beta_ms * ms - k_off * ms
       ds <- alpha_s - beta_s * s - k_on * m * s - k_on * m_pre * s + k_off * ms + k_off * m_pre_s + k_off * m_trunc_s
       dm_pre <- k_init - k_elon * m_pre - k_on * s * m_pre + k_off * m_pre_s - beta_m_co * m_pre
       dm_pre_s <- k_on * s * m_pre - k_off * m_pre_s - k_elon * m_pre_s - beta_ms * m_pre_s - k_coreg * m_pre_s
       dm_trunc_s <- k_coreg * m_pre_s - k_off * m_trunc_s - beta_ms * m_trunc_s
       dp <- k_m * m + k_ms * ms - beta_p * p
       list(c(dm, dms, ds, dm_pre, dm_pre_s, dm_trunc_s, dp))
     })
   }

   # --- Output Metric Function ---
   calculate_protein_regulation_strength <- function(current_params,
                                                     initial_states,
                                                     ode_model_func,
                                                     sim_times = c(0, TIME_FOR_STEADY_STATE), # Use global or pass
                                                     rtol = 1e-6, atol = 1e-10) {

     params_scenario <- current_params
    
     out_scenario_df <- tryCatch({
       out <- deSolve::ode(y = initial_states, times = sim_times, func = ode_model_func,
                           parms = params_scenario, method = "lsoda", rtol = rtol, atol = atol)
       as.data.frame(out)
     }, error = function(e) {
       # warning(paste("ODE solve error (scenario):", e$message));
       NULL
       })
     if (is.null(out_scenario_df) || nrow(out_scenario_df) == 0) return(NA)
     p_scenario <- out_scenario_df[nrow(out_scenario_df), "p"]

     params_no_sRNA <- params_scenario
     params_no_sRNA[["k_on"]] <- 0 # Simulate with no sRNA interaction
    
     out_no_sRNA_df <- tryCatch({
       out <- deSolve::ode(y = initial_states, times = sim_times, func = ode_model_func,
                           parms = params_no_sRNA, method = "lsoda", rtol = rtol, atol = atol)
       as.data.frame(out)
     }, error = function(e) {
       # warning(paste("ODE solve error (no sRNA):", e$message));
       NULL
       })
     if (is.null(out_no_sRNA_df) || nrow(out_no_sRNA_df) == 0) return(NA)
     p_no_sRNA_interaction <- out_no_sRNA_df[nrow(out_no_sRNA_df), "p"]

     if(is.na(p_scenario) || is.na(p_no_sRNA_interaction)) return(NA)

     p_scenario_adj <- p_scenario + PSEUDO_COUNT # Use global PSEUDO_COUNT
     p_no_sRNA_interaction_adj <- p_no_sRNA_interaction + PSEUDO_COUNT

     regulation_strength <- if (abs(p_no_sRNA_interaction_adj) < 1e-12) { # Avoid division by near-zero
                              ifelse(abs(p_scenario_adj) < 1e-12, 0, NA) # If both are zero, no regulation (log2(1)=0)
                            } else {
                              log2(p_scenario_adj / p_no_sRNA_interaction_adj)
                            }

     if(!is.finite(regulation_strength)) return(NA)
     return(regulation_strength)
   }
   ```

**2. `src/gsa_sobol_functions.R`:**
   This file will contain the wrapper for a single GSA run and potentially Sobol result processing/plotting if you want to make `run_gsa_analysis.R` even leaner.

   ```R
   # src/gsa_sobol_functions.R

   # --- Wrapper function for a single GSA run (for parallel execution) ---
   single_gsa_run <- function(scaled_sample_row, # A single row from Sobol design matrix (values 0-1)
                              gsa_param_names_arg,
                              min_ranges_arg, max_ranges_arg,
                              param_distributions_arg, # Named vector: param_name -> "uniform" or "loguniform"
                              baseline_params_arg,
                              initial_states_arg,
                              ode_model_func_arg,
                              calculate_metric_func_arg) {

     unscaled_params <- numeric(length(gsa_param_names_arg))
     names(unscaled_params) <- gsa_param_names_arg

     for (j in 1:length(gsa_param_names_arg)) {
       p_name <- gsa_param_names_arg[j]
       p_scaled_val <- scaled_sample_row[j]
       p_min <- min_ranges_arg[[p_name]] 
       p_max <- max_ranges_arg[[p_name]] 
       dist_type <- param_distributions_arg[[p_name]] 

       if (is.null(dist_type)) stop(paste("Distribution type not specified for parameter:", p_name))

       if (dist_type == "uniform") {
         unscaled_params[p_name] <- p_min + p_scaled_val * (p_max - p_min)
       } else if (dist_type == "loguniform") {
         if (p_min <= 0 || p_max <= 0) stop(paste("Log-uniform ranges for", p_name, "must be positive."))
         log_p_min <- log10(p_min)
         log_p_max <- log10(p_max)
         unscaled_params[p_name] <- 10^(log_p_min + p_scaled_val * (log_p_max - log_p_min))
       } else {
         stop(paste("Unknown distribution type:", dist_type, "for parameter:", p_name))
       }
     }

     params_for_run <- baseline_params_arg
     params_for_run[names(unscaled_params)] <- unscaled_params

     if (any(is.na(params_for_run[gsa_param_names_arg]))) {
        # warning(paste("NA found in parameters for run after unscaling for params:", paste(gsa_param_names_arg, collapse=", ")))
        return(NA)
     }

     return(calculate_metric_func_arg(
       current_params = params_for_run,
       initial_states = initial_states_arg,
       ode_model_func = ode_model_func_arg
     ))
   }


   # --- Function to Unscale Sobol Matrix ---
   unscale_sobol_matrix <- function(sobol_X_matrix, gsa_param_names_arg, min_ranges_arg, max_ranges_arg, param_distributions_arg) {
       unscaled_matrix <- matrix(NA, nrow = nrow(sobol_X_matrix), ncol = ncol(sobol_X_matrix))
       colnames(unscaled_matrix) <- gsa_param_names_arg

       for (j in 1:ncol(sobol_X_matrix)) {
           param_name <- gsa_param_names_arg[j]
           scaled_column_values <- sobol_X_matrix[, j]
           p_min <- min_ranges_arg[param_name]
           p_max <- max_ranges_arg[param_name]
           dist_type <- param_distributions_arg[param_name]

           if (is.na(dist_type)) stop(paste("Distribution type not specified for parameter:", param_name))

           if (dist_type == "uniform") {
               unscaled_matrix[, j] <- p_min + scaled_column_values * (p_max - p_min)
           } else if (dist_type == "loguniform") {
               if (p_min <= 0 || p_max <= 0) stop(paste("Log-uniform ranges for '", param_name, "' must be positive."))
               log_p_min <- log10(p_min)
               log_p_max <- log10(p_max)
               unscaled_matrix[, j] <- 10^(log_p_min + scaled_column_values * (log_p_max - log_p_min))
           } else {
               stop(paste("Unknown distribution type:", dist_type, "for parameter:", param_name))
           }
       }
       return(as.data.frame(unscaled_matrix))
   }


   # --- Function to Plot Sobol Results ---
   plot_sobol_indices <- function(sobol_results_object, varied_param_names) {
       if (!is.null(sobol_results_object$S) && !is.null(sobol_results_object$T)) {
           s1_original <- sobol_results_object$S$original
           s1_min_ci <- sobol_results_object$S$`min. c.i.` # Use backticks
           s1_max_ci <- sobol_results_object$S$`max. c.i.`
           st_original <- sobol_results_object$T$original
           st_min_ci <- sobol_results_object$T$`min. c.i.`
           st_max_ci <- sobol_results_object$T$`max. c.i.`

           results_df_plot <- data.frame(
               Parameter = factor(varied_param_names, levels = varied_param_names), # Ensure consistent factor levels
               S1 = s1_original,
               S1.conf.low = s1_min_ci,
               S1.conf.high = s1_max_ci,
               ST = st_original,
               ST.conf.low = st_min_ci,
               ST.conf.high = st_max_ci
           )
           results_long_df_plot <- tidyr::pivot_longer(results_df_plot,
                                                       cols = c(S1, ST),
                                                       names_to = "Index_Type",
                                                       values_to = "Value")
           results_long_df_plot$CI_low <- ifelse(results_long_df_plot$Index_Type == "S1",
                                                 results_long_df_plot$S1.conf.low,
                                                 results_long_df_plot$ST.conf.low)
           results_long_df_plot$CI_high <- ifelse(results_long_df_plot$Index_Type == "S1",
                                                  results_long_df_plot$S1.conf.high,
                                                  results_long_df_plot$ST.conf.high)

           p <- ggplot(results_long_df_plot, aes(x = Parameter, y = Value, fill = Index_Type)) +
               geom_bar(stat="identity", position=position_dodge(width=0.9)) +
               geom_errorbar(aes(ymin = CI_low, ymax = CI_high),
                             position = position_dodge(width=0.9), width=0.25, linewidth=0.3) +
               labs(title="Sobol Sensitivity Indices",
                    y="Sensitivity Index Value", x = "Parameter") +
               theme_minimal(base_size=12) +
               theme(axis.text.x = element_text(angle=45, hjust=1, vjust=1), # Adjusted vjust
                     plot.title = element_text(hjust=0.5, face="bold")) +
               scale_fill_brewer(palette="Set1", name="Index Type",
                                 labels=c("S1 (First Order)", "ST (Total Order)"))
           return(p)
       } else {
           cat("Could not generate Sobol plot components (S or T missing from object).\n")
           return(NULL)
       }
   }
   ```

**3. `run_gsa_analysis.R` (Main Orchestration Script):**
   This will be the script the user primarily interacts with.

   ```R
   # run_gsa_analysis.R

   # Load Required Packages
   library(sensitivity)
   library(deSolve)
   library(dplyr)
   library(parallel)
   library(ggplot2)
   library(tidyr)

   # Source helper functions
   source("src/model_and_metric_functions.R")
   source("src/gsa_sobol_functions.R")

   # --- 1. Define Baseline Parameters and Initial States ---
   # F_KON_CONVERSION is defined in model_and_metric_functions.R
   k_elon_default_rate <- 25/1000 # Example for a gene of length 1000nt and an elongation rate 0 25nt/s, adjust as needed

   baseline_params <- list(
     k_init    = 0.96,
     alpha_s   = 0.36,
     beta_s    = 1.5e-3,
     beta_m    = 0.002310491,
     beta_ms   = 0.002310491,
     beta_m_co = 0.002310491,
     beta_p    = 0.005,
     k_on      = (1.3e6) / F_KON_CONVERSION, # Molar to molecular conversion
     k_off     = 0.3,
     k_elon    = k_elon_default_rate,
     k_m       = 14.0,
     k_ms      = 14.0,
     k_coreg   = 1.0 
   )

   default_initial_states <- c(
     m = 0, ms = 0, s = baseline_params$alpha_s / baseline_params$beta_s,
     m_pre = 0, m_pre_s = 0, m_trunc_s = 0, p = 0
   )

   # --- 2. Define Parameters for GSA ---
   # List of parameters to vary, their ranges, and distributions
   gsa_parameters_definition <- list(
     k_init    = list(min=0.1,    max=2,    dist="uniform"),
     alpha_s   = list(min=0.1,    max=2,    dist="uniform"),
     k_on      = list(min=1.660578e-06, max=0.1660578 , dist="loguniform"),
     k_off     = list(min=1e-3,   max=100,  dist="loguniform"),
     beta_m    = list(min=0.0002, max=0.06, dist="loguniform"),
     beta_ms   = list(min=0.0002, max=0.06, dist="loguniform"),
     beta_s    = list(min=0.0002, max=0.06, dist="loguniform"),
     k_coreg   = list(min=0.01,   max=0.99, dist="uniform"),
     k_elon    = list(min=5/1000, max=60/1000, dist="uniform"),
     beta_m_co = list(min=0.0001, max=0.06, dist="loguniform"),
     beta_p    = list(min=0.0005, max=0.05, dist="loguniform"), 
     k_m       = list(min=0.1,    max=30,   dist="uniform"),
     k_ms      = list(min=0.1,    max=30,   dist="uniform")
   )

   gsa_param_names_to_vary <- names(gsa_parameters_definition)
   k_gsa_varied <- length(gsa_param_names_to_vary)

   min_ranges_for_gsa <- sapply(gsa_parameters_definition, function(p) p$min)
   max_ranges_for_gsa <- sapply(gsa_parameters_definition, function(p) p$max)
   param_distributions_for_gsa <- sapply(gsa_parameters_definition, function(p) p$dist)


   # --- 3. Run Sobol GSA (in Parallel) ---
   n_base_samples_sobol <- 1e5 # ADJUST AS NEEDED (e.g., 1e3 for quick, 1e4+ for robust)
   cat("Preparing Sobol GSA with", n_base_samples_sobol, "base samples for", k_gsa_varied, "parameters.\n")

   # Generate Sobol design matrices (scaled 0-1)
   X1_sobol <- data.frame(matrix(runif(n_base_samples_sobol * k_gsa_varied), nrow = n_base_samples_sobol, byrow = TRUE))
   X2_sobol <- data.frame(matrix(runif(n_base_samples_sobol * k_gsa_varied), nrow = n_base_samples_sobol, byrow = TRUE))

   sobol_design_object <- sensitivity::sobolSalt(model = NULL, X1 = X1_sobol, X2 = X2_sobol, nboot = 100) 

   # Setup for parallel execution
   num_cores_to_use <- max(1, parallel::detectCores() - 1)
   cat("Using", num_cores_to_use, "cores for parallel execution.\n")
   gsa_cluster <- parallel::makeCluster(num_cores_to_use)

   # Export necessary variables and functions to the cluster
   parallel::clusterExport(gsa_cluster, c("single_gsa_run", "calculate_protein_regulation_strength", "model_func_gsa",
                                     "gsa_param_names_to_vary", "min_ranges_for_gsa", "max_ranges_for_gsa",
                                     "param_distributions_for_gsa", "baseline_params", "default_initial_states",
                                     "F_KON_CONVERSION", "PSEUDO_COUNT", "TIME_FOR_STEADY_STATE")) # Ensure all globals are exported
   parallel::clusterEvalQ(gsa_cluster, { library(deSolve) }) # Load deSolve on each worker

   cat("Starting parallel model evaluations for GSA...\n")
   # sobol_design_object$X contains all parameter sets to run (N * (k+2) rows)
   gsa_model_outputs <- NA
   tryCatch({
     gsa_model_outputs <- parallel::parApply(gsa_cluster, sobol_design_object$X, 1, single_gsa_run,
                                       gsa_param_names_arg = gsa_param_names_to_vary,
                                       min_ranges_arg = min_ranges_for_gsa,
                                       max_ranges_arg = max_ranges_for_gsa,
                                       param_distributions_arg = param_distributions_for_gsa,
                                       baseline_params_arg = baseline_params,
                                       initial_states_arg = default_initial_states,
                                       ode_model_func_arg = model_func_gsa,
                                       calculate_metric_func_arg = calculate_protein_regulation_strength)
   }, finally = {
     parallel::stopCluster(gsa_cluster) # Always stop the cluster
     cat("Parallel execution finished or stopped.\n")
   })


   if(all(is.na(gsa_model_outputs))) {
       stop("All GSA model outputs are NA. Cannot proceed. Check errors during single_gsa_run execution or parameter ranges.")
   } else if (anyNA(gsa_model_outputs)) {
       num_na_outputs <- sum(is.na(gsa_model_outputs))
       warning(paste(num_na_outputs, "NA values produced in GSA output. Results might be unreliable. Consider checking parameter ranges or ODE stability. Imputing with median for Sobol calculation."))
       median_output_for_imputation <- median(gsa_model_outputs, na.rm=TRUE)
       if (is.na(median_output_for_imputation) && num_na_outputs < length(gsa_model_outputs)) { # if median is NA but not all are NA
           warning("Median for imputation is NA, attempting to use mean.")
           mean_output_for_imputation <- mean(gsa_model_outputs, na.rm=TRUE)
            if(is.na(mean_output_for_imputation)){
                stop("Cannot impute NAs as both median and mean are NA. Too many NAs or problematic output values.")
            }
           gsa_model_outputs[is.na(gsa_model_outputs)] <- mean_output_for_imputation
       } else if (is.na(median_output_for_imputation) && num_na_outputs == length(gsa_model_outputs)) {
            stop("All GSA outputs are NA even after trying to get median. Cannot proceed.")
       } else {
            gsa_model_outputs[is.na(gsa_model_outputs)] <- median_output_for_imputation
       }
       if(all(is.na(gsa_model_outputs))) stop("All GSA outputs are still NA after imputation. Cannot proceed.") 
   }


   # --- 4. Calculate and Print Sobol Indices ---
   cat("Calculating Sobol indices...\n")
   sensitivity::tell(sobol_design_object, gsa_model_outputs) # Assigns y to the sobol object
   cat("\nSobol GSA Results Object Summary:\n")
   print(sobol_design_object) # This will print S1, ST etc.

   # --- 5. Plot GSA Results ---
   cat("\nPlotting Sobol indices...\n")
   sobol_plot <- plot_sobol_indices(sobol_design_object, gsa_param_names_to_vary)
   if (!is.null(sobol_plot)) {
       print(sobol_plot)
       ggsave(file.path("results", "sobol_indices.png"), plot = sobol_plot, width = 10, height = 7)
       cat("Sobol indices plot saved to results/sobol_indices.png\n")
   }

   # --- 6. Unscale Parameters and Combine with Outputs for Further Analysis ---
   unscaled_parameters_df_gsa <- unscale_sobol_matrix(
       sobol_design_object$X,
       gsa_param_names_to_vary,
       min_ranges_for_gsa,
       max_ranges_for_gsa,
       param_distributions_for_gsa
   )

   # Combine unscaled parameters with GSA output values
   if (length(gsa_model_outputs) == nrow(unscaled_parameters_df_gsa)) {
     gsa_results_with_inputs_df <- cbind(unscaled_parameters_df_gsa, regulation_strength = gsa_model_outputs)
     print(head(gsa_results_with_inputs_df))

     # Save the combined data and the sobol object for further analysis
     gsa_output_data <- list(
         gsa_results_with_inputs_df = gsa_results_with_inputs_df, # Data for regression, plotting etc.
         sobol_indices_summary = sobol_design_object, # Contains S, T, etc.
         gsa_parameter_definitions = gsa_parameters_definition # For reference
     )
     save(gsa_output_data, file = file.path("results", "gsa_analysis_outputs.RData"))

   } else {
     cat(paste("Error: 'gsa_model_outputs' length (", length(gsa_model_outputs),
               ") does not match the number of GSA samples in design matrix (",
               nrow(unscaled_parameters_df_gsa), ").\n"))
   }

   ```

**Key improvements in this structure:**

* **Modularity:** Easier to understand and maintain.
* **Clarity:** The `run_gsa_analysis.R` script becomes a high-level workflow controller.
* **Reusability:** Functions in `src/` can potentially be reused in other projects.
* **README:** Provides essential context for anyone looking at the repository.

**To make this fully functional, you would:**

1.  Create the directory structure as outlined.
2.  Save the content for `README.md` into `gsa_ode_project/README.md`.
3.  Save the R code for `model_and_metric_functions.R` into `gsa_ode_project/src/model_and_metric_functions.R`.
4.  Save the R code for `gsa_sobol_functions.R` into `gsa_ode_project/src/gsa_sobol_functions.R`.
5.  Save the R code for `run_gsa_analysis.R` into `gsa_ode_project/run_gsa_analysis.R`.
6.  Create an initial `.gitignore` file (you can find templates online, e.g., for R projects, or start with `results/`, `*.RData`, `*.Rhistory`).

This structure provides a good, clean setup for a GitHub repository for your GSA project. Remember to thoroughly test each part! I've made some adjustments to the `calculate_protein_regulation_strength` function for robustness with very small protein values and added more detailed error handling/massages in the main script. Also, the k_on range in `gsa_parameters_definition` might need adjustment based on whether your model function expects molar k_on and if the original values were already molar or molecular. I've assumed the provided min/max for `k_on` in `gsa_parameters_definition` in your script were already in the desired units for sampling.
